---
layout: post
title:      "MealPlanner JS SPA"
date:       2020-08-11 12:54:37 -0400
permalink:  mealplanner_js_spa
---


For my JS Single Page Application project, I revisited a problem of my sinatra project. In that project I wanted to create a way to list recipes, link them to ingredients, and track which ingredients the user had in their inventory. One of my stretch goals for that app was to create a way for users to schedule meals, so I've decided to tackle that here.

![](https://drive.google.com/file/d/13Ci3YRf7gNYfnqfgSN0btTworail7K_6/view?usp=sharing)

First, to set up the models, I'm using the same join model I used before: Recipes (now meals) have many Ingredients through MealsIngredients (and vice versa). I currently only included a few Ingredients seeded into the database, but eventually want to find a way to scrape info from different sources to get various food items, and their calories per quantity. The quantity of an ingredient per meal is recorded on the join model. For this project since the meals will all need to be recorded to a schedule, I also made a column for the datetime that the meal was/will be eaten on. In the future, it might also be valuable to allow users to create their own ingredients, add modifiers to the amount of calories. Also important would be unit conversions, so that an ingredient measured in how many cups or pounds of an item can convert to grams if needed. It could also be important to account for multiple servings, so a user can make a meal, but say that they only ate half and will have the rest as leftovers.

Another stretch goal for the project is to implement a user pantry and shopping list. This would be very convenient for a schedule, since it can track what items you have, and also indicate which of those are going to be used within that week. With expiration dates, it could even tell you what day you have to use the item by, and suggest meals based on recipes saved.

First I set up a table to work as the display of the schedule, with headers along the top showing the date, and along the sides showing the hour. Apps similar to this usually have users list whether a meal was breakfast, lunch, or dinner, but it's convenient to have it listed by hour, especially for anyone doing intermittent fasting. Tables have convenient methods like .cellIndex and .rowIndex that allow you to easily access where in the table you are. I still struggled with rendering the meals in the correct cells, and realized I was going about it in such a convoluted way. At first I was taking the string given from the api, which was in a different format than how I wrote the dates in the headers. Since I set the date headers to start at the current day, I decided to use those as the comparison to see where the meal was supposed to go. I first tried creating a new Date with the string given from the api, but it kept showing the day number for the day before it. My quick fix was to just add 1 to the index when placing the meal, which worked for every day except the current day. I finally realized the power of .substr; I could just grab the proper day number from the api string, and compare it to the day numbers of each header. After a month the user would start to overlap meal plans, but it can easily be fixed by first testing that the month and year are correct. As usual, the simplest solution proved to be the best, and I should have recognized that feeling of "doing too much" that typically means you're going down a bad path with your code.

Setting up the form was probably the most fun. At first I wanted to use Bootstrap popovers, but they proved tricky and I didn't want to waste too much time on them if there was an easier way to get an MVP up and running. I instead rendered the form on the side. It was interesting to see how JS fetch requests handle nested parameters compared to Rails. I found it to be a bit easier, once I realized you can really set up the params hash just as easily with JS Objects. Including multiple ingredients was easy, and on the backend, I only needed to find each ingredient by the name from the params, and create an instance of the join model linking it to the new meal.

While we're comparing JS and Rails, the biggest difference is how much freedom we have in JS versus the rigid conventions of Rails. In JS there are countless ways to go about each problem, and very rarely are any of the options "wrong". Some of them may be a bit cumbersome and inefficient however, but it seems like best practice for an application without any frontend framework is to be as consistent as possible. My approach was to create a catch all event listener for clicks, and perform logic on the clicked item based on it's id or class name matching one of the options. So when a user clicks anywhere on the page, it checks whether the clicked item is an empty cell, and if it is generates the new meal form. If the user clicks on an existing meal it shows the details to the side. Whenever possible, I also tried to add lots of new elements in bulk by just adding to another element's innerHTML. One instance where that wasn't possible was setting up the ability to add multiple ingredients. Trying to write the new input all as a single HTML string kept giving me errors, so I shifted gears and just created a new input element and set the attributes accordingly.

At the end of this project, I'm very excited to start using React, since this felt like a lot of work for little payoff. I'm hoping that frontend frameworks will make the process of writing in JS go a lot easier and faster so that I can take apps further. I'm considering continuing with this concept in the final project, and see if I can make a complete version that incorporates all of the features I've wanted since the beginning.


Github repo links: [frontend](https://github.com/Bryce-Du/MealPlanner-Frontend) [backend](https://github.com/Bryce-Du/MealPlanner-Backend)


