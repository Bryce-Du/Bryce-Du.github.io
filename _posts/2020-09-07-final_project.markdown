---
layout: post
title:      "Final Project"
date:       2020-09-07 14:37:39 +0000
permalink:  final_project
---


Welcome back to the final leg of our journey in the world of Recipe/Inventory/Mealplanning Apps. In the first project we scraped the Food Network website for recipes and their associated ingredients. In the next section we made a platform for users to track their recipes and ingredients in Sinatra. In the vanilla JS project, I created a calendar to track meals. For our grand finale, we're putting all of these together in React.

The overarching goals of this project are to aid users in planning meals, tracking calories, and reducing food waste. I have always found cooking to be fun when I'm doing it, and I usually like what I cook, but getting motivated to cook and coming up with what to cook is the worst. I always hate it anytime I buy something hoping to cook it but it goes bad by the time I get around to making it. With this app, I'm hoping to clear away a lot of the fear and anxiety around food and give structure to the planning of meals. We eat every day and it can be a fulfilling and exciting thing, instead of a stressor.

I first set up my backend; very similar to my Sinatra project, I made three models (User, Recipe, Ingredient) with joins between each. The join models on Ingredient each handle quantity - the Recipes_Ingredient needs to know how many of that item the recipe calls for, and the Users_Ingredient needs to know how many the User currently holds. 

When I began setting up the React components for my different models, I used a similar approach to how I made views in Rails, but quickly realized that this created a lot of unnecessary code when in the world of React. React allows and encourages reusable code. For instance, rather than display ingredients as a list in one view and as inputs in the form, I could allow my IngredientInput components to display either an empty input for the user to fill in the ingredient they were adding, or set it to be read-only and give it the name of a pre-existing ingredient. This made that component effective whether the user was adding ingredients to a recipe, or adding them to their pantry.

Redux was probably the most confusing part of this module at first. I felt a little uneasy doing the redux labs, because I could get the tests to pass but could not confidently explain how. I think part of the confusion stemmed from the reducers and actions being self-contained. It helped to view Redux as an encapsulated box that you insert information into and can receive a predictable result. I think when we learn procedural and imperative programming, we get a taste for controlling the code and knowing exactly what the data is at every point. As we move to an object-oriented and declarative style, we lose a lot of that control. It's important to see this as a benefit, that we don't need to think too hard about what exactly a component or function is doing if it's been built correctly.

This even further stresses the need for things to be built as properly as possible but raises a question of what is proper. It's easy to write code that works, but has several asterisks and sarcastic quote marks around the word works. If you're the only one ever using your code and you'll never need to update it, that might pass, but since that applies to the tiniest fraction of code you'll ever write, you want to make code that is predictable, scalable, and refactored.

The Object-Oriented principle that is best represented in React(and Redux) is encapsulation. Encapsulation is a way to refactor code such that complicated logic can exist within a more digestible "capsule" that you can call upon as often as you need, and know that you'll get the desired result. We use encapsulation all the time in non-coding "algorithms". If someone asks where they can find the local supermarket, you would give them driving directions and assume they knew what you meant. The complex logic of driving is contained within the street directions you're giving, if they don't know how to drive they may have more important questions to ask. You're passing on a higher-order instruction, with faith that all the steps, from unlocking the car doors, opening them, sitting in the drivers seat, etc. are obvious. 

Encapsulated code then should be obvious, from the name a function or class is given, to what parameters it accepts and what value it returns. String.prototype.toUpperCase() is a good example, calling this on a string returns that string, but with every character in uppercase. There's a chunk of string logic being used, but you don't need to go through and write it all yourself when there's a convenient built in method like this. If you tried to DIY the whole process of coding, eventually you'd be stripped down to concerning yourself with moving electrons through logic gates.

When I finished a few features involving redux, I was ready to keep using it for everything! What a powerful tool that lets each component take advantage of some universally relevant information. This got trickier when I started making controlled forms. It's certainly possible to make controlled forms that all leverage the store, but I decided instead to have one container component connected, that passes props down to its children and then dispatches the result on submit.

## Future Goals
There are still a few more features that need to be implemented to fulfill my longer-term goals for this project. User login is currently incredibly insecure, and there is no session storage so you have to log in with every refresh. These compound to make a very annoying development experience as Chrome gives you a warning with every log in about just how unsafe the password is.

There's a distinction to be made between the recipe (the food algorithm) and the meals (what you actually ate/were planning to eat). It might be best to store this information inside the Users_Recipes join model. It being a many-to-many relationship would allow for the same user to eat the same meal more than once, while only saving one copy of the recipe. The join model could hold another value for the date that it was eaten, and how many servings were made versus how many you ate that day. In my previous project I had a full calendar, but the time of eating things isn't entirely necessary. It may be easier and more view-space-efficient to just display planned or eaten meals in column form.

Another important addition to be made is the ability to convert items between different measurements. My ingredient class is fairly light at the moment, offering no way to add new items outside the seed file. I made enough to get things started and show recipe and pantry functionality, but more work will be needed to get ingredients stored and converted into any measurement the user desires. Part of me thinks it could be useful to find (or fun to create) a ruby gem that handles conversions of quantities that might be displayed as any kind of string into a number or string of a different measurement.

I also hope to add a column to the UsersIngredients that tracks how long until the item expires, and displays notifications when an item is almost going bad with recommended recipes that use that item up. One of the biggest causes of food waste for me is forgetting that I even had any of an item I wanted to cook with.

## Post-Mortem
Having completed 5 projects here at Flatiron, I can see some patterns emerging. The most notable is that I usually take a few days to warm up, where I'm still trying to figure out the tech that we're using. The labs and lessons only take you so far, and trying to jump right into a full project is not without its hurdles. On around day 4 of working, I complete a feature that feels like a Big Deal, and it gets me really thirsty for more of that my-code-works-finally dopamine hit. It seems likely that I could tap into that phenomenon and aim to make one big feature as soon as possible to get the project started. The set up is the most daunting point, which ironically enough is exactly the problem this app was designed to solve in the realm of cooking!

